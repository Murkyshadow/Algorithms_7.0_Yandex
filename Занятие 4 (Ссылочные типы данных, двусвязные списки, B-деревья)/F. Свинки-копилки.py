# сколько же копилок нужно разбить, чтобы добраться до всех копилок?
# если некоторое кол-во копилок объединены (ключ от одной находится в другой) в одну последовательность,
# тогда, чтобы добраться до всех копилок необходимо разбить одну копилку (с той, с которой эта последовательность
# или же любая если последовательность зациклена)
# получается все сводится к тому сколько существует последовательностей не связанных друг с другом
# для этого будем проходиться по копилкам и объединять их в одну последовательность


n = int(input())
peegs = [int(input())-1 for _ in range(n)]  # делаем нумерацию кипилок с нуля
sets = [set([i]) for i in range(n)]  # храним связанные копилки в одном множестве
num_set_peeg = list(range(n))    # для каждой копилки храним в каком множестве она находится (изначально у каждой свинки копилки свое множество)
count_sets = n  # кол-во не пустых последовательностей (множеств)
for ind_now_peeg, ind_peeg_with_key in enumerate(peegs):  # ind_peeg_with_key - индекс копилки, в которой находится ключ от текущей копилки
    if ind_now_peeg != ind_peeg_with_key and num_set_peeg[ind_now_peeg] != num_set_peeg[ind_peeg_with_key]:   # ключ от копилки находится не в этой же копилке и разные копилки находятся в разных множествах
        if len(sets[num_set_peeg[ind_now_peeg]]) > len(sets[num_set_peeg[ind_peeg_with_key]]):    # объединяем множества связанных свинок (при этом меньшее множество кладем в большее)
            ind_set_for_del = num_set_peeg[ind_peeg_with_key]   # из меньшей удаляем
            ind_set_for_add = num_set_peeg[ind_now_peeg]    # в большу добавляем
        else:
            ind_set_for_del = num_set_peeg[ind_now_peeg]
            ind_set_for_add = num_set_peeg[ind_peeg_with_key]
        while len(sets[ind_set_for_del]) > 0:   # объединяем множества (из меньшего переносим эл в большее)
            del_el = sets[ind_set_for_del].pop()
            sets[ind_set_for_add].add(del_el)
            num_set_peeg[del_el] = ind_set_for_add
        sets[ind_set_for_del] = None    # удаляем пустое множество, иначе не пройдет по памяти (или же можно использовать списки - они занимают меньше места (праоверено✔))
        count_sets -= 1
print(count_sets)    # выводим кол-во не пустых множеств (от общего кол-ва отнимаем кол-во пустых)
